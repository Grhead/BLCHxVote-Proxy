// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.10
// source: MainService.proto

package __

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Contract_NewChain_FullMethodName           = "/Contract/NewChain"
	Contract_CallCreateVoters_FullMethodName   = "/Contract/CallCreateVoters"
	Contract_CallNewCandidate_FullMethodName   = "/Contract/CallNewCandidate"
	Contract_CallViewCandidates_FullMethodName = "/Contract/CallViewCandidates"
	Contract_WinnersList_FullMethodName        = "/Contract/WinnersList"
	Contract_SoloWinner_FullMethodName         = "/Contract/SoloWinner"
	Contract_ChainSize_FullMethodName          = "/Contract/ChainSize"
	Contract_GetPartOfChain_FullMethodName     = "/Contract/GetPartOfChain"
	Contract_GetFullChain_FullMethodName       = "/Contract/GetFullChain"
	Contract_AcceptNewUser_FullMethodName      = "/Contract/AcceptNewUser"
	Contract_AcceptLoadUser_FullMethodName     = "/Contract/AcceptLoadUser"
	Contract_Vote_FullMethodName               = "/Contract/Vote"
)

// ContractClient is the client API for Contract service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContractClient interface {
	// rpc BasicAuth() returns ();
	// rpc BasicRegister() returns ();
	NewChain(ctx context.Context, in *NewChainRequest, opts ...grpc.CallOption) (*NewChainResponse, error)
	CallCreateVoters(ctx context.Context, in *CallCreateVotersRequest, opts ...grpc.CallOption) (*CallCreateVotersResponse, error)
	CallNewCandidate(ctx context.Context, in *CallNewCandidateRequest, opts ...grpc.CallOption) (*CallNewCandidateResponse, error)
	CallViewCandidates(ctx context.Context, in *CallViewCandidatesRequest, opts ...grpc.CallOption) (*CallViewCandidatesResponse, error)
	WinnersList(ctx context.Context, in *WinnersListRequest, opts ...grpc.CallOption) (*WinnersListResponse, error)
	SoloWinner(ctx context.Context, in *SoloWinnerRequest, opts ...grpc.CallOption) (*SoloWinnerResponse, error)
	ChainSize(ctx context.Context, in *ChainSizeRequest, opts ...grpc.CallOption) (*ChainSizeResponse, error)
	GetPartOfChain(ctx context.Context, in *GetPartOfChainRequest, opts ...grpc.CallOption) (*GetPartOfChainResponse, error)
	GetFullChain(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetFullChainResponse, error)
	AcceptNewUser(ctx context.Context, in *AcceptNewUserRequest, opts ...grpc.CallOption) (*AcceptNewUserResponse, error)
	AcceptLoadUser(ctx context.Context, in *AcceptLoadUserRequest, opts ...grpc.CallOption) (*AcceptLoadUserResponse, error)
	Vote(ctx context.Context, in *VoteRequest, opts ...grpc.CallOption) (*VoteResponse, error)
}

type contractClient struct {
	cc grpc.ClientConnInterface
}

func NewContractClient(cc grpc.ClientConnInterface) ContractClient {
	return &contractClient{cc}
}

func (c *contractClient) NewChain(ctx context.Context, in *NewChainRequest, opts ...grpc.CallOption) (*NewChainResponse, error) {
	out := new(NewChainResponse)
	err := c.cc.Invoke(ctx, Contract_NewChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) CallCreateVoters(ctx context.Context, in *CallCreateVotersRequest, opts ...grpc.CallOption) (*CallCreateVotersResponse, error) {
	out := new(CallCreateVotersResponse)
	err := c.cc.Invoke(ctx, Contract_CallCreateVoters_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) CallNewCandidate(ctx context.Context, in *CallNewCandidateRequest, opts ...grpc.CallOption) (*CallNewCandidateResponse, error) {
	out := new(CallNewCandidateResponse)
	err := c.cc.Invoke(ctx, Contract_CallNewCandidate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) CallViewCandidates(ctx context.Context, in *CallViewCandidatesRequest, opts ...grpc.CallOption) (*CallViewCandidatesResponse, error) {
	out := new(CallViewCandidatesResponse)
	err := c.cc.Invoke(ctx, Contract_CallViewCandidates_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) WinnersList(ctx context.Context, in *WinnersListRequest, opts ...grpc.CallOption) (*WinnersListResponse, error) {
	out := new(WinnersListResponse)
	err := c.cc.Invoke(ctx, Contract_WinnersList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) SoloWinner(ctx context.Context, in *SoloWinnerRequest, opts ...grpc.CallOption) (*SoloWinnerResponse, error) {
	out := new(SoloWinnerResponse)
	err := c.cc.Invoke(ctx, Contract_SoloWinner_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) ChainSize(ctx context.Context, in *ChainSizeRequest, opts ...grpc.CallOption) (*ChainSizeResponse, error) {
	out := new(ChainSizeResponse)
	err := c.cc.Invoke(ctx, Contract_ChainSize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) GetPartOfChain(ctx context.Context, in *GetPartOfChainRequest, opts ...grpc.CallOption) (*GetPartOfChainResponse, error) {
	out := new(GetPartOfChainResponse)
	err := c.cc.Invoke(ctx, Contract_GetPartOfChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) GetFullChain(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetFullChainResponse, error) {
	out := new(GetFullChainResponse)
	err := c.cc.Invoke(ctx, Contract_GetFullChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) AcceptNewUser(ctx context.Context, in *AcceptNewUserRequest, opts ...grpc.CallOption) (*AcceptNewUserResponse, error) {
	out := new(AcceptNewUserResponse)
	err := c.cc.Invoke(ctx, Contract_AcceptNewUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) AcceptLoadUser(ctx context.Context, in *AcceptLoadUserRequest, opts ...grpc.CallOption) (*AcceptLoadUserResponse, error) {
	out := new(AcceptLoadUserResponse)
	err := c.cc.Invoke(ctx, Contract_AcceptLoadUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contractClient) Vote(ctx context.Context, in *VoteRequest, opts ...grpc.CallOption) (*VoteResponse, error) {
	out := new(VoteResponse)
	err := c.cc.Invoke(ctx, Contract_Vote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContractServer is the server API for Contract service.
// All implementations must embed UnimplementedContractServer
// for forward compatibility
type ContractServer interface {
	// rpc BasicAuth() returns ();
	// rpc BasicRegister() returns ();
	NewChain(context.Context, *NewChainRequest) (*NewChainResponse, error)
	CallCreateVoters(context.Context, *CallCreateVotersRequest) (*CallCreateVotersResponse, error)
	CallNewCandidate(context.Context, *CallNewCandidateRequest) (*CallNewCandidateResponse, error)
	CallViewCandidates(context.Context, *CallViewCandidatesRequest) (*CallViewCandidatesResponse, error)
	WinnersList(context.Context, *WinnersListRequest) (*WinnersListResponse, error)
	SoloWinner(context.Context, *SoloWinnerRequest) (*SoloWinnerResponse, error)
	ChainSize(context.Context, *ChainSizeRequest) (*ChainSizeResponse, error)
	GetPartOfChain(context.Context, *GetPartOfChainRequest) (*GetPartOfChainResponse, error)
	GetFullChain(context.Context, *empty.Empty) (*GetFullChainResponse, error)
	AcceptNewUser(context.Context, *AcceptNewUserRequest) (*AcceptNewUserResponse, error)
	AcceptLoadUser(context.Context, *AcceptLoadUserRequest) (*AcceptLoadUserResponse, error)
	Vote(context.Context, *VoteRequest) (*VoteResponse, error)
	mustEmbedUnimplementedContractServer()
}

// UnimplementedContractServer must be embedded to have forward compatible implementations.
type UnimplementedContractServer struct {
}

func (UnimplementedContractServer) NewChain(context.Context, *NewChainRequest) (*NewChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewChain not implemented")
}
func (UnimplementedContractServer) CallCreateVoters(context.Context, *CallCreateVotersRequest) (*CallCreateVotersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallCreateVoters not implemented")
}
func (UnimplementedContractServer) CallNewCandidate(context.Context, *CallNewCandidateRequest) (*CallNewCandidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallNewCandidate not implemented")
}
func (UnimplementedContractServer) CallViewCandidates(context.Context, *CallViewCandidatesRequest) (*CallViewCandidatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallViewCandidates not implemented")
}
func (UnimplementedContractServer) WinnersList(context.Context, *WinnersListRequest) (*WinnersListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WinnersList not implemented")
}
func (UnimplementedContractServer) SoloWinner(context.Context, *SoloWinnerRequest) (*SoloWinnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SoloWinner not implemented")
}
func (UnimplementedContractServer) ChainSize(context.Context, *ChainSizeRequest) (*ChainSizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChainSize not implemented")
}
func (UnimplementedContractServer) GetPartOfChain(context.Context, *GetPartOfChainRequest) (*GetPartOfChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPartOfChain not implemented")
}
func (UnimplementedContractServer) GetFullChain(context.Context, *empty.Empty) (*GetFullChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFullChain not implemented")
}
func (UnimplementedContractServer) AcceptNewUser(context.Context, *AcceptNewUserRequest) (*AcceptNewUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptNewUser not implemented")
}
func (UnimplementedContractServer) AcceptLoadUser(context.Context, *AcceptLoadUserRequest) (*AcceptLoadUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptLoadUser not implemented")
}
func (UnimplementedContractServer) Vote(context.Context, *VoteRequest) (*VoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Vote not implemented")
}
func (UnimplementedContractServer) mustEmbedUnimplementedContractServer() {}

// UnsafeContractServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContractServer will
// result in compilation errors.
type UnsafeContractServer interface {
	mustEmbedUnimplementedContractServer()
}

func RegisterContractServer(s grpc.ServiceRegistrar, srv ContractServer) {
	s.RegisterService(&Contract_ServiceDesc, srv)
}

func _Contract_NewChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).NewChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_NewChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).NewChain(ctx, req.(*NewChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_CallCreateVoters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallCreateVotersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).CallCreateVoters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_CallCreateVoters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).CallCreateVoters(ctx, req.(*CallCreateVotersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_CallNewCandidate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallNewCandidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).CallNewCandidate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_CallNewCandidate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).CallNewCandidate(ctx, req.(*CallNewCandidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_CallViewCandidates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallViewCandidatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).CallViewCandidates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_CallViewCandidates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).CallViewCandidates(ctx, req.(*CallViewCandidatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_WinnersList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WinnersListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).WinnersList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_WinnersList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).WinnersList(ctx, req.(*WinnersListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_SoloWinner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SoloWinnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).SoloWinner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_SoloWinner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).SoloWinner(ctx, req.(*SoloWinnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_ChainSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).ChainSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_ChainSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).ChainSize(ctx, req.(*ChainSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_GetPartOfChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPartOfChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).GetPartOfChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_GetPartOfChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).GetPartOfChain(ctx, req.(*GetPartOfChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_GetFullChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).GetFullChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_GetFullChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).GetFullChain(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_AcceptNewUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptNewUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).AcceptNewUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_AcceptNewUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).AcceptNewUser(ctx, req.(*AcceptNewUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_AcceptLoadUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptLoadUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).AcceptLoadUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_AcceptLoadUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).AcceptLoadUser(ctx, req.(*AcceptLoadUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contract_Vote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContractServer).Vote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contract_Vote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContractServer).Vote(ctx, req.(*VoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Contract_ServiceDesc is the grpc.ServiceDesc for Contract service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Contract_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Contract",
	HandlerType: (*ContractServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewChain",
			Handler:    _Contract_NewChain_Handler,
		},
		{
			MethodName: "CallCreateVoters",
			Handler:    _Contract_CallCreateVoters_Handler,
		},
		{
			MethodName: "CallNewCandidate",
			Handler:    _Contract_CallNewCandidate_Handler,
		},
		{
			MethodName: "CallViewCandidates",
			Handler:    _Contract_CallViewCandidates_Handler,
		},
		{
			MethodName: "WinnersList",
			Handler:    _Contract_WinnersList_Handler,
		},
		{
			MethodName: "SoloWinner",
			Handler:    _Contract_SoloWinner_Handler,
		},
		{
			MethodName: "ChainSize",
			Handler:    _Contract_ChainSize_Handler,
		},
		{
			MethodName: "GetPartOfChain",
			Handler:    _Contract_GetPartOfChain_Handler,
		},
		{
			MethodName: "GetFullChain",
			Handler:    _Contract_GetFullChain_Handler,
		},
		{
			MethodName: "AcceptNewUser",
			Handler:    _Contract_AcceptNewUser_Handler,
		},
		{
			MethodName: "AcceptLoadUser",
			Handler:    _Contract_AcceptLoadUser_Handler,
		},
		{
			MethodName: "Vote",
			Handler:    _Contract_Vote_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "MainService.proto",
}
